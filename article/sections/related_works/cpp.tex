\subsection{Compilers}
In \cite{hassan2017}, several C++ compilers were compared, with the goal of finding a balance between performance and energy efficiency. The different coding styles introduced examined the impact of splitting CPU and IO operations and interrupting CPU-intensive instructions with sleep statements. The C++ compilers used in \cite{hassan2017} included MinGW GCC, Cygwin GCC, Borland C++, and Visual C++, and the energy measurements were taken using Windows Performance Analyzer (WPA). The compilers were used with their default settings, and no optimizations options were used. %This decision was based on works like \cite{lima2013}, where it was found that mainstream compilers apply multiple optimizations to the final code, which in the worst case may result in worse performance and increased energy consumption. The issue of optimizations being highly machine-dependent was also demonstrated in \cite{cooper2004}, where analysis and optimizations were conducted on a Texas Instruments C6200 DSP CPU. In \cite{cooper2004}, it was discovered that a significant portion of the energy was used by fetching instructions, which was addressed by introducing a fetch packet mechanism. The study also found loop-unrolling to reduce energy consumption. While these optimizations decreased energy consumption for the Texas Instruments C6200 DSP CPU, the authors noted that varying results were expected for other CPUs. A similar conclusion was also reached in
 They found that when choosing a compiler and coding style, energy reduction depended on the specification of the target machine and the individual application. Based on the benchmark used, which involved an election sort algorithm, the lowest execution time was achieved with the Borland compiler, and the lowest energy consumption was observed with the Visual C++ compiler. When considering the coding styles, the study found that separating IO and CPU operations and interrupting CPU-intensive instructions with sleep statements both decreased energy consumption.