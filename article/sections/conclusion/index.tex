\section{Conclusion}\label[section]{conclusion and Future Work}

% opsumering at vi har 4 RQ, og dem vil vi svare p√•

This work explores parallelism, P- and E-cores, and how this affects energy consumption and execution time, focusing primarily on Windows, with Linux as a reference point. This study is based on four research questions about areas that have yet to be explored on Windows in the literature. The first research question revolves around compilers' impact on energy consumption and execution time. The second research question looks into different software-based measuring instruments for Windows. The third research question looks into the effect parallelism has on energy consumption. Finally, the fourth research question analyzes and compares P- and E-cores.


For each experiment, initial measurements are made before analyzing the results. The initial measurements are made to ensure confidence in the results by applying Cochran's formula to the results. Cochran's formula is used in this work to ensure enough measurements are made, given a desired confidence level and margin of error. We find that the sample size determined by Cochran's formula is, in many cases, larger than what is currently seen in the literature. The sample size found is, in some cases, so large that an upper limit of $1.000$ measurements is introduced, as the gain from additional measurements is found to be limited. This work has a primary focus on Windows. Through the analysis and comparisons with Linux, Windows is found to provide valuable depth to the analysis of energy consumption, whereas Linux is overall found to be the more convenient OS choice due to its minimalist nature with less pre-installed software and background processes. Reaching definitive conclusions is challenging as the results are very hardware and compiler dependent, and similar observations are not guaranteed between OSs. Given this, we conclude that Windows will be a valuable addition to any research about the energy consumption of software. 

When presenting the results, dynamic energy consumption is used to isolate the energy consumption of the benchmark. However, an analysis of the idle energy consumption found that the energy consumption varies between working and non-working hours. Therefore, it is worth exploring the advantages and disadvantages of representing multiple measurements taken over an extended period as a single value in future work.

%% RQ1: c++ compler
Since RAPL is not available on Windows, we compare alternative measuring instruments by measuring energy consumption on C++ microbenchmarks compiled with the most energy efficient compiler of the ones we test. In the first experiment, Intel's oneAPI was found to be the most energy efficient, where a significant difference in performance between compilers is observed. We found that oneAPI achieves the best performance due to its utilization of AVX for parallelism and other optimizations.

%because of its use of parallelism and \texttt{ymm} registers, only found on Intel CPUs.

%% RQ2: measuring instruments
The second experiment tests different measuring instruments to decide which to use on Windows. The experiment compares measurements made by different measuring instruments against a ground truth, where a moderate to high correlation between $0.59$ - $0.80$ is found. Between the different software-based measuring instruments, similar measurements are made, which is expected to result from using the same registers when reporting energy consumption. In the end, Intel Power Gadget is chosen as our preferred software-based measuring instrument because of its usability compared to other measuring instruments. In addition to different software-based measuring instruments, a cheaper alternative to the ground truth is also included: a smart plug. Similar correlations to the software-based measuring instruments are found when comparing the correlation between the plug and clamp. When looking at the analysis conducted on the measuring instruments, some aspects are not included, which could be interesting to look into in a future work, e.g., the overhead of the different measuring instruments.

%% RQ4: Effect of P- and E- cores
In the third experiment, we analyze the performance of P- and E-cores, which in one case shows a $17.40\%$ higher energy consumption for P-cores, while E-cores have a $29.52\%$ higher execution time when executing on four cores, showing that E-cores can be used to limit energy consumption when a higher execution time can be afforded. However, there are cases where the E-cores have a higher energy consumption than P-cores.


% In the third experiment, we analyze the performance of P- and E-cores, which shows a lower execution time and total dynamic energy consumption for P-cores, but a higher dynamic energy consumption per second compared to E-cores. This indicates that for most benchmarks, the P-cores are preferred. However, the intended workload for E-cores is small, non-time-critical jobs, which is our microbenchmarks do not simulate. In future work, the P- and E-cores setup should be tested with more focus on workloads intended for E-cores.

%% RQ3: the effect parallelism has on energy consumption
In the third experiment, parallelism and its effect on energy consumption are explored using two macrobenchmarks, PCMark 10 and 3DMark. One represents a realistic use case, including tasks such as video conferencing, web browsing, and video editing, while the other simulates a more demanding workload. Both macrobenchmarks are executed on an increasing amount of cores to examine the effects of additional resources. For both macrobenchmarks, similar observations are found. When more cores are allocated, the execution time decreases, and DEC per second increases, but the DEC remains the same. This shows that there is no correlation between execution time and energy consumption.  

%For both macrobenchmarks, we find a relationship between the total dynamic energy consumption, execution time, and dynamic energy consumption per second. As more cores are allocated, the execution time and total dynamic energy consumption decrease, while the dynamic energy consumption per second increases. However, the relationship is non-linear, with the execution time decreasing more than the dynamic energy consumption, illustrating diminishing returns. This diminishing return means that at a certain number of cores, additional cores have no notable effect on the execution time or the total dynamic energy consumption, and this number of cores is expected to be higher for more demanding workloads.

\section{future work}
Future work can further explore the impact of compilers on energy consumption and execution time, as this study only tested a limited number of compilers. It may be worth examining the impact of more compilers, including different versions, on energy consumption and execution time. Additionally, further investigation is needed to determine the impact of the measuring instrument overhead on the results and to explore alternative measuring instruments. The study only considered software-based measuring instruments and two hardware based, additional measuring instruments such as oscilloscopes can be used in future work to improve the measurement accuracy. It is also worth exploring different ways of representing multiple measurements taken over an extended period as a single value. Finally, future work can extend the analysis to other operating systems and hardware configurations to determine if similar observations hold. Future work can further investigate the impact of reactive energy consumption on energy trends and how it affects the DEC calculation. It may be useful to explore more accurate ways of representing and calculating the DEC that take into account changes in reactive energy consumption and differences in energy consumption during working and non-working hours. Furthermore, additional research could examine the impact of background processes on energy consumption during benchmark execution and explore methods for identifying and disabling these processes to improve measurement accuracy. By addressing these limitations and exploring alternative approaches, future work could improve the accuracy and reliability of energy consumption analysis in software.