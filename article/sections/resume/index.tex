\section*{Summary}

The paper \textit{'Exploring the Energy Consumption of Highly Parallel Software on Windows} delves into the challenges of measuring the energy consumption of software on the Windows operating system. Whereas most existing work for measuring the energy consumption of software is based on Linux, this work aims to overcome the challenges of measuring energy consumption on Windows and make it more accessible. The paper investigates different aspects of the process, such as finding and evaluating tools available on Windows, testing DUTs with symmetric and asymmetric CPU architectures, and using benchmarks to measure and compare their energy consumption in various situations. The work is based on the following four research questions:

\begin{itemize}
    \item RQ1: How does the C++ compiler used to compile the benchmarks impact energy consumption?
    \item RQ2: What are the advantages and drawbacks of the different measuring instruments for Windows regarding accuracy, ease of use, and availability?
    \item RQ3: What effect does parallelism have on the energy consumption of the benchmarks?
    \item RQ4: What effect do P- and E-cores have on the parallel execution of a process?
\end{itemize}

The first experiment focuses on RQ1, where different C++ compilers are tested to find the most energy-efficient one. The results showed that the Intel oneAPI was the most energy-efficient and had the fastest execution time. Given the good performance of oneAPI, it is used in the second experiment. The second experiment focuses on RQ2 and aims to find the best measuring instrument defined in terms of accuracy, ease of use, and availability, where the experiment was conducted by comparing the correlation of the measuring instruments against a ground truth. In the end, similar performance is found between the tested measuring instruments. However, given the ease of use, Intel Power Gadget was the most usable instrument among those tested. Therefore, the third experiment uses Intel Power Gadget, which focuses on RQ3 and RQ4. In the third experiment, the effect of parallelism on the energy consumption of benchmarks is examined by executing two macrobenchmarks on an increasing number of cores. This experiment finds that more resources results in a lower execution time, while the energy consumption will remain the same. Finally, the effect of P- and E-cores on the parallel execution of a process is analyzed. There are two parts, where one part executes the same microbenchmark on one core at a time, and the other by executing macrobenchmarks on four cores, as either four P-cores, 2 P- and 2 E-cores, or 4 E-cores. This experiment found that P-cores will have a lower execution time, while E-cores, in some cases, have a lower energy consumption.

\paragraph*{}
The paper's discussion section provides further insights into the research. Firstly, Cochran's formula was used to determine the number of measurements needed to gain confidence in the results. Cochran's formula found that results deviated between benchmarks, measuring instruments, DUTs, and even cores on the same DUT. This could be due to the variability in the fabrication process, which can cause changes in the exact characteristics of each core. Another cause of this could be the CPU, as it is found that CPUs with a high TDP can result in a high deviation, which results in many measurements being required. Because of this, an upper limit of $1.000$ measurement was introduced, as the additional measurements had a limited effect on the results. Secondly, the paper analyzes the results of comparing different C++ compilers, where it was found that the energy consumption, execution time, and measurements required deviated between compilers. The analysis showed that oneAPI performs better because it uses AVX functions and Advanced Vector Extensions to perform calculations in parallel. A discussion is also made about some observed energy usage trends during the experiments. The trend observed saw the energy consumption of the idle computer increase during work hours and decrease during the night. This was caused by reactive energy consumption, which depends on the time of the day. Another topic discussed is time synchronization issues, as devices like the Raspberry Pi and an Analog Discovery 2 each kept their time, which could have caused issues if they were not synchronized. The data acquisition process was changed to ensure the devices were synchronized every second, but small time drifts could still occur over time.

\paragraph*{}
In conclusion, this research addresses the challenges of measuring software energy consumption on Windows and provides valuable insights into the impact of different factors on energy consumption and execution time. The paper demonstrates the importance of choosing an energy-efficient compiler and using the right tools to measure energy consumption accurately. The findings also suggest that using E-cores can limit energy consumption and that the impact of parallelism on energy consumption is mixed. This paper's results demonstrate the need for more research into software energy consumption on Windows and the importance of considering various factors when developing energy-efficient software. Future research can build on this study's findings and help reduce the environmental impact of software development. 

%The study also shows that the statistical and practical methods used in this domain for energy measurements still need to be improved.
% The paper 'Exploring the Energy Consumption of Highly Parallel Software on Windows' delves into the challenges of measuring the energy consumption of software on the Windows operating system. The research area of energy consumption of software is largely focused on Linux, which has resulted in a wealth of knowledge on measuring energy consumption. However, this paper aims to overcome the challenges of measuring energy consumption on Windows and make it more accessible. To achieve this goal, the paper investigates different aspects of the process, such as finding and evaluating tools available on Windows, testing DUTs with homogenous and heterogenous cpu architectures, and using different benchmarks to measure and compare their energy consumption in various situations.

% To assist in this endeavor, the paper has formulated four research questions. 

% The first research question focused on evaluating different C++ compilers to find the most energy-efficient compiler to run the microbenchmarks on. The results showed that the Intel oneApi best C++ compiler was not only the most energy-efficient but also the fastest in terms of execution speed. 

% The second research question investigated which measurement tool worked best in terms of accuracy, ease of use, and availability. The paper found that the Intel Power Gadget was the most usable instrument among those tested.

% The third research question examined the effect of parallelism on the energy consumption of benchmarks and found that parallelism did not change the total consumption much. 

% Finally, the fourth research question studied the effect of P- and E-cores on the parallel execution of a process and found that the E-cores used less energy than P-cores.

% The discussion section of the paper builds on the results in Section 5 and provides further insights into the research. Specifically, it delves into some of the deviations in results that were observed, analyzes the C++ benchmark results, discusses energy usage trends, addresses time synchronization issues, and examines the use of Cochran's formula. 
% Firstly, Cochran's formula was used to determine the number of measurements needed to gain confidence in the results. However, the paper found that results could deviate a lot between benchmarks, measuring instrument, DUTs, and even cores on the same DUT. This could be due to the variability in the fabrication process, which can cause changes in the exact characteristics of each core. As such, the energy consumption could have a standard deviation of up to 5.67\% among cores of the same type.
% Secondly, the paper analyzes the results of comparing different C++ compilers. It was found that the energy consumption, execution time, and measurements required deviated between compilers. The analysis showed that the oneAPI had a better performance because it used AVX functions, Advanced Vector Extensions, to perform calculations in parallel.
% Thirdly, the paper discusses the energy usage trends observed during the experiments. While the DEC decreased as more measurements were made, this trend was not observed on any software-based measuring instruments. Therefore, the observed reduction in energy consumption may be caused by changes in the reactive energy consumption, which seemed to be dependent on the time of the day and which the measurements were made. 
% Fourthly, time synchronization issues were addressed in the paper. Devices such as the DUTs, a Raspberry Pi, and an Analog Discovery 2 each kept their time, which could have caused issues if they were not synchronized. The data acquisition process was changed to ensure that the devices were synchronized every second, but small time drifts could still occur over time.
% Finally, the paper examines the use of Cochran's formula. The upper limit was introduced as additional measurements had a limited effect on the results. Thoygh more measurements were still needed to achieve the desired confidence.

% In conclusion, this research addresses the challenges of measuring software energy consumption on Windows and provides valuable insights into the impact of different factors on energy consumption and execution time. The paper demonstrates the importance of choosing an energy-efficient compiler and using the right tools to measure energy consumption accurately. The findings also suggest that using E-cores can limit energy consumption and that the impact of parallelism on energy consumption is mixed. This study highlights Windows' potential for future research in software energy consumption and suggests further research on the impact of practical factors on multiple measurements taken over an extended period. This paper's results demonstrate the need for future research into softwares energy consumption on Windows and the importance of considering various factors when developing energy-efficient software. By exploring the impact of practical factors, looking at different compilers, examining E-cores, and using Windows, future research can build on this study's findings and help reduce the environmental impact of software development. The study also shows that the method both statistically and practically used in this domain for the energy measurements are lacking.


% Artiklen 'Exploring the Energy Consumption of Highly Parallel Software on Windows' undersøger forskellige aspekter omkring strømforbruget af software med et primært fokus på Windows ved hjælp af fire forskningsspørgsmål. Disse fire forskningsspørgsmål er formuleret på baggrund af huller litteraturen, hvor man blandt andet i høj grad bruger Linux og måler strømforbruget ved hjælp af det Linux eksklusive målingsværktøj RAPL. Et af forskningsspørgsmålene undersøger derfor effektiviteten af eksisterende alternativer til RAPL, som fungere på Windows. Det bedste måleværktøj findes ved at kompilere C++ programmer på den mest energy venlige C++ kompiler, som er emnet for det første forskningsspørgsmål. Her ender Intel' oneAPI med at være den kompiler med det laveste energy forbrug, baseret på strømforbruget af to benchmarks kompilet på kompileren.


% Ud over at være primært baseret på Windows, adskiller dette studie sig også ved brugen af Cochrans formel. Cochran's formel anvendes til at beregne antallet af målinger, der kræves, før man kan have tillid til sine resultater. Ved hjælp af Cochrans formel ser vi også litteraturen har en tendens til at have for få målinger i forhold til det antal, som vi finder tilstrækkeligt.


% \paragraph{}
% Det bedste målingsværktøj til Windows bliver fundet ved at sammenligne målingerne med en referencemåling foretaget med en strømklemme samt ved at tage brugervenligheden i betragtning. Det bedste måleværktøj viser sig at være  Intel's Power Gadget, med en korrelation på $0.72$ i forhold til strømklemmen. Når man sammenligner de forskellige måleinstrumenter, viser det sig imidlertid, at de have en lignende korrelation, men at Intel's Power Gadget var mere brugervenligt.


% Det tredje forskningsspørgsmål undersøger effekten af at parallelisere forskellige benchmarks. Dette gøres ved at køre det samme benchmark på et stigende antal af kerner for at se, hvad det gør ved både strømforbruget og køretiden. Resultatet af dette eksperiment viser, at der var en sammenhæng mellem køretiden og energiforbruget, da begge falder, når der er flere kerner, samt at energiforbruget er sekund steg. Baseret på dette, er det konkluderet at et højere antal kerner er bedre, men kun indtil en grænse, som afhænger af arbejdsbyrden.


% Det fjerde forskningsspørgsmål sammenlignede de to forskellige typer kerner, der findes på de nyeste Intel CPU'er, nemlig P- og E kerner. Dette eksperiment blev udført ved at køre det sammen benchmark på en kerne ad gangen og derefter beregne det gennemsnitlige energiforbrug og køretid for de to typer kerner. Resultaterne viste, at de mere kraftfulde P-kerner havde en lavere køretid og energiforbrug, mens E-kerner havde et lavere energiforbrug per sekund.
