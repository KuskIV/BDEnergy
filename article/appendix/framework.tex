\section{The Framework}\label{app:framework}

The framework used in this work was an extension to \cite{biksbois}. The framework was called Biks Diagnostics Energy (BDE) and was a command line tool which could be executed in two ways, as illustrated in \cref{lst:bde_start}, where one was with a configuration, and one was with a path to an executable file.

\input{listings/start-bde.tex}

When using \texttt{--config}, the user specified a path to a valid json file formatted like \cref{lst:bde_json}. Through \cref{lst:bde_json}, it was possible to specify paths to executable files and assign each executable file with a parameter in \texttt{BenchmarkPaths} and \texttt{BenchmarkParameter} respectively. Information like the \texttt{compiler}, \texttt{language}, etc could also be specified the configuration. It was also possible to specify the affinity of the benchmark through \texttt{AllocatedCores}, where an empty list represented the use of all cores and the list \texttt{1,2} stated core $1$ and $2$ was be used. When multiple affinities are specified, each benchmark would be run on both. Limits for the temperature the benchmarks should be executed within could also be specified, and lastly, \texttt{AdditionalMetadata} could be used to specify relevant aspects about the experiment, which could not already be specified through the configuration.

\input{listings/valid_json.tex}

\paragraph*{}
When using the parameters \texttt{--path}, the \texttt{--parameter} was an optional way to provide the executable with parameters. When using BDE this way, a default configuration was set up, containing all fields in the configuration, except \texttt{BenchmarkPath} and \texttt{BenchmarkParameter}.
\newpage

\input{listings/dut_service.tex}

Both Windows and Linux were supported on BDE. This was supported through the \texttt{IDutService} seen in \cref{lst:dut_service}, where all OS dependent operations were located. This included the ability to enable and disable the Wi-Fi, stop background processes, ect.

\input{listings/measuring_instrument.tex}

\paragraph*{}
BDE also supported multiple measuring instruments, through a parent class \texttt{MeasuringInstrument} in \cref{lst:measuring_instrument} the measuring instruments could inherit from. \texttt{MeasuringInstrument} implemented a start (line $10$) and stop (line $19$) method, and a method which retrieved the data measured between the start and stop. The virtual methods were measuring instrument specific, which was why they could be overwritten. This included a start (line $34$) and stop (line $32$) method, a method to parse the measurement data in line $30$ and a method in line $36$ which performed a measurement by default every 100ms. The method in line $36$ was made for measuring instruments like RAPL, where an action is required to read the energy consumption.
\newpage

\input{listings/perform_measurement.tex}

\cref{lst:perform_measurement_bde} showed how BDE performed measurements given the configuration. In the configuration, the burn-in period could be set to any positive integer, where if this value is one, the boolean \texttt{burninApplied} would be set to \texttt{true}, and the measurements would be initialized in line $7$. This initialization would, if the results should be uploaded to the database, mean BDE would fetch existing results from the database, where the configuration was the same, and continue where it was left off. Otherwise, an empty list would be returned. If \texttt{burninApplied} was set to \texttt{false}, the amount of burn-in specified in the configuration would be performed before initializing the measurements.

Next, a do-while loop was entered in line $9$, which would execute until the condition \texttt{EnoughMeasurements} from line $28$ was met. Inside the do-while loop, a cooldown would occur in line $12$, until the DUT was below and above the temperature limits specified in the configuration. Once this is achieved, the Wi-Fi/Ethernet is disabled, and \texttt{PerformMeasurementsForAllConfigs} would then iterate over all measuring instruments and benchmarks specified, and perform one measurement for all permutations. Afterward, a few checks were made. If the burn-in period was over, and the configuration stated that the results should be uploaded to the database, \texttt{UploadMeasurementsToDatabase} was called. If the burn-in period was not over yet, but \texttt{IsBurnInCountAchieved} is \texttt{true}, the measurements was initialized similarly to line $7$, and the boolean \texttt{burninIsApplied} was set to \texttt{true}, indicating that the burn-in period was over, and the measurements were about to be taken. 
